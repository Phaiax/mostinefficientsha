var searchIndex = {};
searchIndex["mostinefficientsha"] = {"doc":"This crate tries to break SHA256. (But fails unfortunately).","items":[[0,"util","mostinefficientsha","Encoding helpers between ascii, u32 and f64 representations of 256 bit hashes.",null,null],[5,"hex","mostinefficientsha::util","Hex encodes eight u32 numbers to a big-endian 64 characters lowercase 0-9a-f hash representation.",null,null],[5,"dehex","","Parses a big-endian 64 characters 0-9a-f hash representation to eight u32 numbers in system endianess.",null,{"inputs":[{"name":"str"}],"output":{"name":"box"}}],[5,"f64bits_to_u32","","Takes 256 bits where each bit is represented by a float.",null,null],[5,"u32_to_f64bits","","The inverse of `f64bits_to_u32()`. Creates 256 doubles\nthat are either 1.0 or 0.0 . return_value[0] is the MSBit.",null,null],[0,"term","mostinefficientsha","`term::Term`: A fuzzy bit.",null,null],[3,"Term","mostinefficientsha::term","A `Term` is either [constant, symbolic or the result of a logical operation\nof other terms](enum.TermType.html).",null,null],[4,"TermType","","Types of Terms.",null,null],[13,"Symbol","","",0,null],[13,"Constant","","",0,null],[13,"Xor","","",0,null],[13,"And","","",0,null],[13,"Or","","",0,null],[13,"Not","","",0,null],[6,"RTerm","","The always used Handle for any `Term`.",null,null],[11,"clone","","",1,null],[11,"clone","","",0,null],[11,"symbol","","Create a `Symbol` type term with unassigned value. Assign value with `set()`.",1,{"inputs":[],"output":{"name":"rterm"}}],[11,"c1","","Shortcut for creating a `true` constant.",1,{"inputs":[],"output":{"name":"rterm"}}],[11,"c0","","Shortcut for creating a `false` constant.",1,{"inputs":[],"output":{"name":"rterm"}}],[11,"constant","","Create a `Constant` type term with given value.",1,{"inputs":[{"name":"bool"}],"output":{"name":"rterm"}}],[11,"is_const","","Checks if this term is of type constant.",1,null],[11,"const_val","","Returns the constant value of this `Term`.\nPanics if type is not `Constant`.",1,null],[11,"xor","","Creates a new `RTerm` that lazily evaluates to the xor operation `a ^ b`\nof the two input terms.",1,{"inputs":[{"name":"rterm"},{"name":"rterm"}],"output":{"name":"rterm"}}],[11,"or","","Creates a new `RTerm` that lazily evaluates to the or operation `a | b`\nof the two input terms.",1,{"inputs":[{"name":"rterm"},{"name":"rterm"}],"output":{"name":"rterm"}}],[11,"and","","Creates a new `RTerm` that lazily evaluates to the and operation `a &amp; b`\nof the two input terms.",1,{"inputs":[{"name":"rterm"},{"name":"rterm"}],"output":{"name":"rterm"}}],[11,"not","","Creates a new `RTerm` that lazily evaluates to the not operation `!a`\nof the input term.",1,{"inputs":[{"name":"rterm"}],"output":{"name":"rterm"}}],[11,"half_add","","Shortcut for (  a^b  ,  a&amp;b  ). The first term is the sum bit of a logic\nhalf adder, the second term is the carry bit.",1,null],[11,"full_add","","Shortcut for (  a^b^c  ,  (a&amp;b)^(c&amp;(a^b))  ).\nThe first term is the sum bit of a logic full adder,\nthe second term is the carry bit.",1,null],[11,"set","","Sets the value of a `Symbol` type term.\nPanics if the type is not `Symbol`.",1,null],[11,"reset","","Reset the cached value of this term and all terms this term depends on.\nDoes not reset anything if this term has already been reset.",1,null],[11,"evaluate","","Evaluate this term by recursively evaluating all sub terms.\nCache the evaluated value.",1,null],[11,"max_logic_depth_and_max_stack_size","","Stack size needed when evaluating this `Term` recursively.\nThe stack_cnt is the current stack size. (Use 0 at the root term).\nIt also returns the maximum logic depth. This value is created by\nutilizing the eval cache. So you must call `reset()` before and after\nusing this function.",1,null],[11,"nr_of_terms","","Returns the number of RTerms that contribute to the evaluation of this RTerm.\nThis function uses the eval cache, so you must call `reset()` before and\nafter using this function.\nTo prevent double counting, this function returns the actual number on\nthe first call and zero on all following calls.",1,null],[11,"nr_of_terms_flattened","","Returns the number of Terms that contribute to the evaluation if the\ntree would have been flattened.",1,null],[11,"fmt","","",1,null],[0,"u","mostinefficientsha","`u::U`: A fuzzy 32bit integer",null,null],[3,"U","mostinefficientsha::u","This type represents a u32, an unsigned number made of 32 bits.\nThe bits are not boolean, but represented by a lazily evaluated tree of\n`Term`s.",null,null],[12,"bits","","The LSBit is bits[0], the MSBit is bits[31]. The byte order is big endian.\nPush LSB first.",2,null],[11,"clone","","",2,null],[11,"new_symbolic","","Create a new `U` with 32 `Term`s of type `Symbol`. Do not forget to\nset the value of each symbol afterwards. You can set the value of each\nbit by using `my_u.bits[22].set(0.3f64)`. Or set 8 bits of this `U` with\n`my_u.set_byte(&#39;e&#39;, 2)`.",2,{"inputs":[],"output":{"name":"u"}}],[11,"from_const","","Create a new `U` with 32 `Term`s of type `Constant`.",2,{"inputs":[{"name":"u32"}],"output":{"name":"u"}}],[11,"set_byte","","Sets the bits of one byte of this u32 to their min/max values 1.0 and 0.0 depending on `set_value`.\n`bytenum` must be one of 0, 1, 2, 3.\nByte 0 is the most significant byte of the four byte representation of this u32.",2,null],[11,"set_bytes","","Sets all bits of this `U` to a value dependend on `bytes`. See `set_byte()` for details.",2,null],[11,"reset","","Recursively resets the cache of this self&#39;s bits/`Term`s and the `Term`s self&#39;s `Term`s depend on.",2,null],[11,"evaluate","","Evaluates all bits to a f64 value. Push these values to `out`.\nPushes the MSBit first.",2,null],[11,"eval_to_u32","","Evaluate all bits to a `f64` value, then round that value to 0 or 1\nand assemble a `u32` with these bits.",2,null],[11,"max_logic_depth_and_max_stack_size","","Max stack size needed when evaluating each bit of this `U` recursively.",2,null],[11,"nr_of_terms","","Returns the number of `RTerms` that contribute to the evaluation of this `U`.",2,null],[11,"nr_of_terms_flattened","","Returns the number of `Term`s that contribute to the evaluation of this `U` if the\ntree would have been flattened for each bit and subtree.",2,null],[11,"rotate_right","","Returns a new `U` that evaluates to `self`s value, but bitrotated by `x`\nto the right. Rotation happens without any carry bit.\n`x` must be less or equal 32.",2,null],[11,"shift_right","","Returns a new `U` that evaluates to `self`s value, but bitshifted by `x`\nto the right.\n`x` must be less than 32.",2,null],[11,"xor","","Returns a new `U` that evaluates to the bitwise xor with `rhs`.",2,null],[11,"and","","Returns a new `U` that evaluates to the bitwise and with `rhs`.",2,null],[11,"not","","Returns a new `U` that evaluates to the bitwise not with `rhs`.",2,null],[11,"add","","Returns a new `U` that evaluates to the arithmethic addition with `rhs`.",2,null],[11,"from","","",2,{"inputs":[{"name":"u32"}],"output":{"name":"self"}}],[11,"fmt","","Debug: MSB...LSB",2,null],[11,"shr","","",2,null],[11,"add","","",2,null],[11,"add","","",2,null],[11,"not","","",2,null],[11,"bitxor","","",2,null],[11,"bitxor","","",2,null],[11,"bitand","","",2,null],[11,"bitand","","",2,null],[0,"sha","mostinefficientsha","`sha::Sha256`: Sha256 using `U`s.",null,null],[3,"Sha256","mostinefficientsha::sha","This struct does a lazy SHA-256 hash calculation with fuzzy `f64` bits.\nIt first creates a tree\nof thouthands of `Term`s that represent the bitwise calculations needed to\ncalculate the final hash. It then calculates that hash by evaluating the\n`Term`s that represent the bits of the final 256 bit hash value.",null,null],[12,"data","","The original input data. Some of the trailing bits may have been replaced. See `new()`.",3,null],[12,"input_data_len_in_bits","","",3,null],[12,"digest","","The final tree structure is hidden here.",3,null],[11,"new","","Create a new tree of `Term`s, that lazily calculates the SHA-256 hash of `data`.",3,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":{"name":"sha256"}}],[11,"reset","","Resets the cache of all `RTerms` within the `Term` tree.",3,null],[11,"eval_to_u32","","Evaluates the digest/hash result into `u32`s by rounding the `f64` bits.",3,null],[11,"hex","","Evaluates the digest/hash result into its ascii hash representation\nby rounding the `f64` bits.",3,null],[11,"evaluate","","Evaluates the digest/hash results into 256 `f64`s.",3,null],[11,"nr_of_terms","","Returns the number of `Term`s that were created to represent this\ninstance of the SHA-256 algorithm. The number depends heavily on the\nlength of the input data.",3,null],[11,"nr_of_terms_flattened","","Returns the number of `Term`s that would make the flattened version\nof the tree of each bit of the digest.",3,null],[11,"max_logic_depth_and_max_stack_size","","Max stack size needed when evaluating each bit of the digest recursively.",3,null],[11,"statistics","","Returns a String describing the statistics. Same as debug print.",3,null],[11,"fmt","","",3,null],[0,"linopt","mostinefficientsha","`linopt::Linopt`: Linear optimization",null,null],[3,"Linopt","mostinefficientsha::linopt","Simple optimizer that tries to use the fuzzy Sha256 implementation to\ntry to optimize to a target hash using a very simple linerarization algorithm.",null,null],[11,"new","","Uses `len_input_bytes` as the length of the input to the sha256 hash algorithm.\n`target_hash` is the hash it tries to optimize to.",4,{"inputs":[{"name":"usize"},{"name":"str"}],"output":{"name":"linopt"}}],[11,"init","","Inits all input bits to 0.5.",4,null],[11,"optimize","","Run optimization for `rounds` rounds.",4,null],[11,"eval_to_u32","","Evaluate sha algorithm to u32s.",4,null],[11,"hex","","Evaluate sha algorithm to ascii representation.",4,null],[11,"fmt","","",4,null]],"paths":[[4,"TermType"],[3,"Term"],[3,"U"],[3,"Sha256"],[3,"Linopt"]]};
searchIndex["arrayvec"] = {"doc":"**arrayvec** provides the types `ArrayVec` and `ArrayString`:\narray-backed vector and string types, which store their contents inline.","items":[[8,"RangeArgument","arrayvec","**IndexRange** is implemented by Rust&#39;s built-in range types, produced\nby range syntax like `..`, `a..`, `..b` or `c..d`.",null,null],[11,"start","","Start index (inclusive)",0,null],[11,"end","","End index (exclusive)",0,null],[3,"ArrayString","","A string with a fixed capacity.",null,null],[3,"ArrayVec","","A vector with a fixed capacity.",null,null],[3,"IntoIter","","By-value iterator for `ArrayVec`.",null,null],[3,"Drain","","A draining iterator for `ArrayVec`.",null,null],[3,"CapacityError","","Error value indicating insufficient capacity",null,null],[11,"new","","Create a new empty `ArrayString`.",1,{"inputs":[],"output":{"name":"arraystring"}}],[11,"from","","Create a new `ArrayString` from a `str`.",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"capacity","","Return the capacity of the `ArrayString`.",1,null],[11,"push","","Adds the given char to the end of the string.",1,null],[11,"push_str","","Adds the given string slice to the end of the string.",1,null],[11,"clear","","Make the string empty.",1,null],[11,"set_len","","Set the strings&#39;s length.",1,null],[11,"as_str","","Return a string slice of the whole `ArrayString`.",1,null],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"eq","","",1,null],[11,"eq","","",1,null],[11,"hash","","",1,null],[11,"borrow","","",1,null],[11,"as_ref","","",1,null],[11,"fmt","","",1,null],[11,"fmt","","",1,null],[11,"write_str","","",1,null],[11,"clone","","",1,null],[11,"clone_from","","",1,null],[8,"Array","","Trait for fixed size arrays.",null,null],[16,"Item","","The array&#39;s element type",2,null],[11,"drop","","",3,null],[11,"new","","Create a new empty `ArrayVec`.",3,{"inputs":[],"output":{"name":"arrayvec"}}],[11,"len","","Return the number of elements in the `ArrayVec`.",3,null],[11,"capacity","","Return the capacity of the `ArrayVec`.",3,null],[11,"push","","Push `element` to the end of the vector.",3,null],[11,"insert","","Insert `element` in position `index`.",3,null],[11,"pop","","Remove the last element in the vector.",3,null],[11,"swap_remove","","Remove the element at `index` and swap the last element into its place.",3,null],[11,"remove","","Remove the element at `index` and shift down the following elements.",3,null],[11,"clear","","Remove all elements in the vector.",3,null],[11,"retain","","Retains only the elements specified by the predicate.",3,null],[11,"set_len","","Set the vector&#39;s length without dropping or moving out elements",3,null],[11,"drain","","Create a draining iterator that removes the specified range in the vector\nand yields the removed items from start to end. The element range is\nremoved even if the iterator is not consumed until the end.",3,null],[11,"into_inner","","Return the inner fixed size array, if it is full to its capacity.",3,null],[11,"dispose","","Dispose of `self` without the overwriting that is needed in Drop.",3,null],[11,"as_slice","","Return a slice containing all elements of the vector.",3,null],[11,"as_mut_slice","","Return a mutable slice containing all elements of the vector.",3,null],[11,"deref","","",3,null],[11,"deref_mut","","",3,null],[11,"from","","",3,{"inputs":[{"name":"a"}],"output":{"name":"self"}}],[11,"into_iter","","",3,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"next_back","","",4,null],[11,"drop","","",4,null],[11,"next","","",5,null],[11,"size_hint","","",5,null],[11,"next_back","","",5,null],[11,"drop","","",5,null],[11,"extend","","",3,null],[11,"from_iter","","",3,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"clone","","",3,null],[11,"clone_from","","",3,null],[11,"hash","","",3,null],[11,"eq","","",3,null],[11,"eq","","",3,null],[11,"borrow","","",3,null],[11,"borrow_mut","","",3,null],[11,"as_ref","","",3,null],[11,"as_mut","","",3,null],[11,"fmt","","",3,null],[11,"default","","",3,{"inputs":[],"output":{"name":"arrayvec"}}],[11,"partial_cmp","","",3,null],[11,"lt","","",3,null],[11,"le","","",3,null],[11,"ge","","",3,null],[11,"gt","","",3,null],[11,"cmp","","",3,null],[11,"write","","",3,null],[11,"flush","","",3,null],[11,"partial_cmp","","",6,null],[11,"lt","","",6,null],[11,"le","","",6,null],[11,"gt","","",6,null],[11,"ge","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"cmp","","",6,null],[11,"clone","","",6,null],[11,"element","","Extract the overflowing element",6,null],[11,"simplify","","Convert into a `CapacityError` that does not carry an element.",6,null],[11,"description","","",6,null],[11,"fmt","","",6,null],[11,"fmt","","",6,null]],"paths":[[8,"RangeArgument"],[3,"ArrayString"],[8,"Array"],[3,"ArrayVec"],[3,"IntoIter"],[3,"Drain"],[3,"CapacityError"]]};
searchIndex["data_encoding"] = {"doc":"This [crate](https://crates.io/crates/data-encoding) provides\ngeneric data encoding functions.","items":[[0,"base","data_encoding","Generic base module.",null,null],[3,"Opt","data_encoding::base","Optimized implementation.",null,null],[12,"val","","Symbol to value association.",0,null],[12,"sym","","Value to symbol association.",0,null],[12,"bit","","The power of two of the base.",0,null],[12,"pad","","The padding.",0,null],[12,"_phantom","","",0,null],[3,"Spec","","Specification implementation.",null,null],[12,"val","","Symbol to value association.",1,null],[12,"pad","","The padding.",1,null],[4,"ValidError","","Validity errors.",null,null],[13,"BadBit","","The base must be a power of two between 2 and 64\ninclusive.",2,null],[13,"PadNotAscii","","The padding must be an ascii.",2,null],[13,"PadSymbol","","The padding must not be a symbol.",2,null],[13,"SymNotAscii","","Symbols must be ascii.",2,null],[13,"NotValue","","Symbols must be mapped to values.",2,null],[13,"NotInj","","Symbols must be uniquely mapped.",2,null],[13,"NotSurj","","Symbols must be mapped to all values.",2,null],[4,"EqualError","","Equality errors.",null,null],[13,"Symbol","","The two bases differ on a symbol or its associated value.",3,null],[13,"Padding","","The two bases differ on the padding.",3,null],[5,"mask","","Returns the bit-mask of a base.",null,{"inputs":[{"name":"b"}],"output":{"name":"u8"}}],[5,"len","","Returns the period length of a base.",null,{"inputs":[{"name":"b"}],"output":{"name":"usize"}}],[5,"enc","","Returns the encoding length of a base.",null,{"inputs":[{"name":"b"}],"output":{"name":"usize"}}],[5,"dec","","Returns the decoding length of a base.",null,{"inputs":[{"name":"b"}],"output":{"name":"usize"}}],[5,"valid","","Checks whether a base is valid.",null,{"inputs":[{"name":"b"}],"output":{"name":"result"}}],[5,"equal","","Checks whether two bases are equal.",null,{"inputs":[{"name":"b1"},{"name":"b2"}],"output":{"name":"result"}}],[8,"Base","","Generic interface.",null,null],[10,"pad","","Returns the padding.",4,null],[10,"val","","Returns the value of a symbol.",4,null],[11,"bit","","Returns the power of two of the base.",4,null],[11,"sym","","Returns the symbol of a value.",4,null],[11,"bit","","",0,null],[11,"pad","","",0,null],[11,"val","","",0,null],[11,"sym","","",0,null],[11,"pad","","",1,null],[11,"val","","",1,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"description","","",2,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"fmt","","",3,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"description","","",3,null],[0,"encode","data_encoding","Generic encoding module.",null,null],[5,"encode_len","data_encoding::encode","Converts an input length to its output length.",null,{"inputs":[{"name":"b"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"encode_mut","","Generic encoding function without allocation.",null,null],[5,"encode","","Generic encoding function with allocation.",null,null],[0,"decode","data_encoding","Generic decoding module.",null,null],[4,"Error","data_encoding::decode","Decoding errors.",null,null],[13,"BadLength","","Bad input length.",5,null],[13,"BadCharacter","","Bad input character.",5,null],[13,"BadPadding","","Bad padding.",5,null],[5,"decode_len","","Converts an input length to its output length.",null,{"inputs":[{"name":"b"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"decode_mut","","Generic decoding function without allocation.",null,null],[5,"decode","","Generic decoding function with allocation.",null,null],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"shift","","Increments error position.",5,null],[11,"map","","Maps error position.",5,null],[11,"fmt","","",5,null],[11,"description","","",5,null],[0,"base2","data_encoding","Base 2 Encoding.",null,null],[4,"Static","data_encoding::base2","Force static dispatch.",null,null],[5,"base","","Gives access to the base.",null,{"inputs":[],"output":{"name":"opt"}}],[5,"encode_len","","See the generic [`encode_len`](../encode/fn.encode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"decode_len","","See the generic [`decode_len`](../decode/fn.decode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"encode_mut","","See the generic [`encode_mut`](../encode/fn.encode_mut.html) function for details.",null,null],[5,"decode_mut","","See the generic [`decode_mut`](../decode/fn.decode_mut.html) function for details.",null,null],[5,"encode","","See the generic [`encode`](../encode/fn.encode.html) function for details.",null,null],[5,"decode","","See the generic [`decode`](../decode/fn.decode.html) function for details.",null,null],[0,"base4","data_encoding","Base 4 Encoding.",null,null],[4,"Static","data_encoding::base4","Force static dispatch.",null,null],[5,"base","","Gives access to the base.",null,{"inputs":[],"output":{"name":"opt"}}],[5,"encode_len","","See the generic [`encode_len`](../encode/fn.encode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"decode_len","","See the generic [`decode_len`](../decode/fn.decode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"encode_mut","","See the generic [`encode_mut`](../encode/fn.encode_mut.html) function for details.",null,null],[5,"decode_mut","","See the generic [`decode_mut`](../decode/fn.decode_mut.html) function for details.",null,null],[5,"encode","","See the generic [`encode`](../encode/fn.encode.html) function for details.",null,null],[5,"decode","","See the generic [`decode`](../decode/fn.decode.html) function for details.",null,null],[0,"base8","data_encoding","Base 8 Encoding.",null,null],[4,"Static","data_encoding::base8","Force static dispatch.",null,null],[5,"base","","Gives access to the base.",null,{"inputs":[],"output":{"name":"opt"}}],[5,"encode_len","","See the generic [`encode_len`](../encode/fn.encode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"decode_len","","See the generic [`decode_len`](../decode/fn.decode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"encode_mut","","See the generic [`encode_mut`](../encode/fn.encode_mut.html) function for details.",null,null],[5,"decode_mut","","See the generic [`decode_mut`](../decode/fn.decode_mut.html) function for details.",null,null],[5,"encode","","See the generic [`encode`](../encode/fn.encode.html) function for details.",null,null],[5,"decode","","See the generic [`decode`](../decode/fn.decode.html) function for details.",null,null],[0,"base16","data_encoding","Base 16 Encoding.",null,null],[4,"Static","data_encoding::base16","Force static dispatch.",null,null],[5,"base","","Gives access to the base.",null,{"inputs":[],"output":{"name":"opt"}}],[5,"encode_len","","See the generic [`encode_len`](../encode/fn.encode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"decode_len","","See the generic [`decode_len`](../decode/fn.decode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"encode_mut","","See the generic [`encode_mut`](../encode/fn.encode_mut.html) function for details.",null,null],[5,"decode_mut","","See the generic [`decode_mut`](../decode/fn.decode_mut.html) function for details.",null,null],[5,"encode","","See the generic [`encode`](../encode/fn.encode.html) function for details.",null,null],[5,"decode","","See the generic [`decode`](../decode/fn.decode.html) function for details.",null,null],[0,"base32","data_encoding","Base 32 Encoding.",null,null],[4,"Static","data_encoding::base32","Force static dispatch.",null,null],[5,"base","","Gives access to the base.",null,{"inputs":[],"output":{"name":"opt"}}],[5,"encode_len","","See the generic [`encode_len`](../encode/fn.encode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"decode_len","","See the generic [`decode_len`](../decode/fn.decode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"encode_mut","","See the generic [`encode_mut`](../encode/fn.encode_mut.html) function for details.",null,null],[5,"decode_mut","","See the generic [`decode_mut`](../decode/fn.decode_mut.html) function for details.",null,null],[5,"encode","","See the generic [`encode`](../encode/fn.encode.html) function for details.",null,null],[5,"decode","","See the generic [`decode`](../decode/fn.decode.html) function for details.",null,null],[0,"base32hex","data_encoding","Base 32 Encoding with Extended Hex Alphabet.",null,null],[4,"Static","data_encoding::base32hex","Force static dispatch.",null,null],[5,"base","","Gives access to the base.",null,{"inputs":[],"output":{"name":"opt"}}],[5,"encode_len","","See the generic [`encode_len`](../encode/fn.encode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"decode_len","","See the generic [`decode_len`](../decode/fn.decode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"encode_mut","","See the generic [`encode_mut`](../encode/fn.encode_mut.html) function for details.",null,null],[5,"decode_mut","","See the generic [`decode_mut`](../decode/fn.decode_mut.html) function for details.",null,null],[5,"encode","","See the generic [`encode`](../encode/fn.encode.html) function for details.",null,null],[5,"decode","","See the generic [`decode`](../decode/fn.decode.html) function for details.",null,null],[0,"base64","data_encoding","Base 64 Encoding.",null,null],[4,"Static","data_encoding::base64","Force static dispatch.",null,null],[5,"base","","Gives access to the base.",null,{"inputs":[],"output":{"name":"opt"}}],[5,"encode_len","","See the generic [`encode_len`](../encode/fn.encode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"decode_len","","See the generic [`decode_len`](../decode/fn.decode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"encode_mut","","See the generic [`encode_mut`](../encode/fn.encode_mut.html) function for details.",null,null],[5,"decode_mut","","See the generic [`decode_mut`](../decode/fn.decode_mut.html) function for details.",null,null],[5,"encode","","See the generic [`encode`](../encode/fn.encode.html) function for details.",null,null],[5,"decode","","See the generic [`decode`](../decode/fn.decode.html) function for details.",null,null],[0,"base64url","data_encoding","Base 64 Encoding with URL and Filename Safe Alphabet.",null,null],[4,"Static","data_encoding::base64url","Force static dispatch.",null,null],[5,"base","","Gives access to the base.",null,{"inputs":[],"output":{"name":"opt"}}],[5,"encode_len","","See the generic [`encode_len`](../encode/fn.encode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"decode_len","","See the generic [`decode_len`](../decode/fn.decode_len.html) function for details.",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"encode_mut","","See the generic [`encode_mut`](../encode/fn.encode_mut.html) function for details.",null,null],[5,"decode_mut","","See the generic [`decode_mut`](../decode/fn.decode_mut.html) function for details.",null,null],[5,"encode","","See the generic [`encode`](../encode/fn.encode.html) function for details.",null,null],[5,"decode","","See the generic [`decode`](../decode/fn.decode.html) function for details.",null,null]],"paths":[[3,"Opt"],[3,"Spec"],[4,"ValidError"],[4,"EqualError"],[8,"Base"],[4,"Error"]]};
searchIndex["nodrop"] = {"doc":"","items":[[3,"NoDrop","nodrop","A type holding **T** that will not call its destructor on drop",null,null],[11,"new","","Create a new **NoDrop**.",0,{"inputs":[{"name":"t"}],"output":{"name":"nodrop"}}],[11,"into_inner","","Extract the inner value.",0,null],[11,"drop","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null]],"paths":[[3,"NoDrop"]]};
searchIndex["byteorder"] = {"doc":"This crate provides convenience methods for encoding and decoding numbers\nin either big-endian or little-endian order.","items":[[4,"BigEndian","byteorder","Defines big-endian serialization.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[6,"NetworkEndian","","Defines network byte order serialization.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[8,"ReadBytesExt","","Extends `Read` with methods for reading numbers. (For `std::io`.)",null,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[8,"WriteBytesExt","","Extends `Write` with methods for writing numbers. (For `std::io`.)",null,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null],[8,"ByteOrder","","ByteOrder describes types that can serialize integers as bytes.",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",2,null],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",2,null],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",2,null],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",2,null],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",2,null],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",2,null],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",2,null],[10,"write_uint","","Writes an unsigned integer `n` to `buf` using only `nbytes`.",2,null],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",2,null],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",2,null],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",2,null],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",2,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",2,null],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",2,null],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",2,null],[11,"write_int","","Writes a signed integer `n` to `buf` using only `nbytes`.",2,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"read_u16","","",3,null],[11,"read_u32","","",3,null],[11,"read_u64","","",3,null],[11,"read_uint","","",3,null],[11,"write_u16","","",3,null],[11,"write_u32","","",3,null],[11,"write_u64","","",3,null],[11,"write_uint","","",3,null],[11,"read_u16","","",4,null],[11,"read_u32","","",4,null],[11,"read_u64","","",4,null],[11,"read_uint","","",4,null],[11,"write_u16","","",4,null],[11,"write_u32","","",4,null],[11,"write_u64","","",4,null],[11,"write_uint","","",4,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null]],"paths":[[8,"ReadBytesExt"],[8,"WriteBytesExt"],[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
searchIndex["odds"] = {"doc":"Odds and ends â€” collection miscellania.","items":[[3,"Fix","odds","Fixpoint combinator for rust closures, generalized over the return type.",null,null],[12,"0","","",0,null],[5,"ref_eq","","Compare if **a** and **b** are equal *as pointers*.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"bool"}}],[5,"ptr_eq","","Compare if **a** and **b** are equal pointers.",null,null],[5,"raw_byte_repr","","Safe to use with any wholly initialized memory `ptr`",null,null],[5,"get_unchecked","","Use `debug_assert!` to check indexing in debug mode. In release mode, no checks are done.",null,null],[5,"get_unchecked_mut","","Use `debug_assert!` to check indexing in debug mode. In release mode, no checks are done.",null,null],[5,"debug_assert_unreachable","","Act as `debug_assert!` in debug mode, asserting that this point is not reached.",null,null],[5,"slice_unchecked","","Check slicing bounds in debug mode, otherwise just act as an unchecked\nslice call.",null,null],[5,"slice_unchecked_mut","","Check slicing bounds in debug mode, otherwise just act as an unchecked\nslice call.",null,null],[5,"ref_slice","","Create a length 1 slice out of a reference",null,null],[5,"ref_slice_mut","","Create a length 1 mutable slice out of a reference",null,null],[11,"call","","",0,null],[11,"clone","","",0,null],[0,"string","","Extensions to `&amp;str` and `String`",null,null],[3,"Prefixes","odds::string","Iterator of all non-empty prefixes",null,null],[3,"Suffixes","","Iterator of all non-empty suffixes",null,null],[3,"Substrings","","Iterator of all non-empty substrings",null,null],[3,"CharChunks","","An iterator that splits the string in substrings of each `n`\n`char` per substring. The last item will contain the remainder if\n`n` does not divide the char length of the string evenly.",null,null],[3,"CharWindows","","An iterator that produces substrings of each `n`\n`char` per substring in a sliding window that advances one char at a time.",null,null],[8,"StrExt","","Extra methods for `str`",null,null],[10,"rep","","Repeat the string `n` times.",1,null],[10,"append","","Requires `feature=&quot;std&quot;`",1,null],[10,"prefixes","","All non-empty prefixes",1,null],[10,"suffixes","","All non-empty suffixes",1,null],[10,"substrings","","Produce all non-empty substrings",1,null],[10,"is_acceptable_index","","Return `true` if `index` is acceptable for slicing the string.",1,null],[8,"StrSlice","","Extension trait for `str` for string slicing without panicking",null,null],[10,"get_slice","","Return a slice of the string, if it is in bounds /and on character boundaries/,\notherwise return `None`",2,null],[8,"StringExt","","Extra methods for `String`",null,null],[10,"insert_str","","**Panics** if `index` is out of bounds.",3,null],[8,"StrChunksWindows","","Extension traits for the `char_chunks` and `char_windows` methods",null,null],[10,"char_chunks","","Return an iterator that splits the string in substrings of each `n`\n`char` per substring. The last item will contain the remainder if\n`n` does not divide the char length of the string evenly.",4,null],[10,"char_windows","","Return an iterator that produces substrings of each `n`\n`char` per substring in a sliding window that advances one char at a time.",4,null],[11,"clone","","",5,null],[11,"next","","",5,null],[11,"clone","","",6,null],[11,"next","","",6,null],[11,"clone","","",7,null],[11,"next","","",7,null],[11,"fmt","","",8,null],[11,"clone","","",8,null],[11,"next","","",8,null],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"next","","",9,null],[0,"vec","odds","Extensions to `Vec`",null,null],[8,"VecExt","odds::vec","Extra methods for `Vec&lt;T&gt;`",null,null],[10,"splice","","Remove elements in a range, and insert from an iterator in their place.",10,null],[10,"retain_mut","","Retains only the elements specified by the predicate.",10,null],[0,"slice","odds","Extra functions for slices",null,null],[5,"shared_prefix","odds::slice","Return the end index of the longest shared (equal) prefix of `a` and `b`.",null,null],[8,"IndexRange","odds","**IndexRange** is implemented by Rust&#39;s built-in range types, produced\nby range syntax like `..`, `a..`, `..b` or `c..d`.",null,null],[11,"start","","Start index (inclusive)",11,null],[11,"end","","End index (exclusive)",11,null],[11,"start","","Start index (inclusive)",11,null],[11,"end","","End index (exclusive)",11,null]],"paths":[[3,"Fix"],[8,"StrExt"],[8,"StrSlice"],[8,"StringExt"],[8,"StrChunksWindows"],[3,"Prefixes"],[3,"Suffixes"],[3,"Substrings"],[3,"CharChunks"],[3,"CharWindows"],[8,"VecExt"],[8,"IndexRange"]]};
initSearch(searchIndex);
